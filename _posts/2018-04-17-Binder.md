---

layout: post
title: "Binder篇"
date: 2018-04-17
categories: android

---

Tags : ZAZE android

[TOC]

* TOC
{:toc}

---

# Binder篇

## 参考资料

部分图片和解读说明摘自以下参考资料。

### 链接

[为什么Android要采用Binder作为IPC机制][为什么Android要采用Binder作为IPC机制]
[Linux设备驱动之字符设备驱动][Linux设备驱动之字符设备驱动]
[Linux字符设备驱动框架][Linux字符设备驱动框架]

### 书籍

> **<< Android的设计和实现:卷I>>**
> **<<深入理解Android: 卷I>>**

## 一、 初窥Binder

### 1.1 什么是Binder

```
    首先一句话概括 : Binder在Android中被用于进行进程间通信(IPC)。
    Android 是使用Linux的进程管理机制，以进程为单位分配虚拟地址空间。为了安全考虑，一个进程禁止直接与其他进程交互,也就是不同进程之间是相互隔离的(Process Isolation)。这时候如果需要进行通信，就必须通过Linux内核提供的进程间通讯(Inter Process Communication, IPC),具体的通信方式看下方。但是这些IPC方式要么效率低下，要么不适合封装给上层使用, 所以在Android 中并没有大规模使用，取而代之的使用Binder。
```
```
- Binder是Android对Linux内核层的一个扩展，属于字符设备驱动。主要操作有驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。
- Binder框架分成Native层和Java层。
- Android通过对Binder的封装，提供了一套Binder操作的框架，便于上层使用。
```

### 1.2 理解下Linux的字符设备驱动

```
    设备驱动程序（英语：device driver），简称驱动程序（driver），是一个允许高阶（High level）电脑软件（computer software）与硬件（hardware）交互的程序，这种程序创建了一个硬件与硬件，或硬件与软件沟通的接口，经由主板上的总线（bus）或其它沟通子系统（subsystem）与硬件形成连接的机制，这样的机制使得硬件设备（device）上的数据交换成为可能。

    字符设备(无缓冲)：只能一个字节一个字节的读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后顺序进行。字符设备是面向流的设备，常见的字符设备如鼠标、键盘、串口、控制台、LED等。
    块设备(有缓冲)：是指可以从设备的任意位置读取一定长度的数据设备。块设备如硬盘、磁盘、U盘和SD卡等存储设备。
    网络设备：网络设备比较特殊，不在是对文件进行操作，而是由专门的网络接口来实现。应用程序不能直接访问网络设备驱动程序。在/dev目录下也没有文件来表示网络设备。
    对于字符设备和块设备来说，在/dev目录下都有对应的设备文件。linux用户程序通过设备文件或叫做设备节点来使用驱动程序操作字符设备和块设备。

   字符设备驱动程序通常至少要实现open、close、read、write系统调用。字符设备可以通过文件系统节点来访问，这些设备文件和普通文件之间的唯一差别在于对普通文件的访问可以前后移动访问位置，而大多数字符设备是一个只能顺序访问的数据通道。一个字符设备是一种字节流设备，对设备的存取只能按顺序按字节的存取而不能随机访问，字符设备没有请求缓冲区，所有的访问请求都是按顺序执行的。
   
    Linux一切皆文件，所有的设备访问都是通过文件的方式，一般的数据文件、程序普通文件，设备节点称为设备文件(open、close、read、write)。
    Linux的内核中大量使用"注册+回调"机制进行驱动程序的编写，所谓注册回调，简单的理解，就是当我们open一个设备文件的时候，其实是通过虚拟文件系统(Virtual File System ,VFS)找到相应的inode(索引节点)，并执行此前创建这个设备文件时注册在inode中的open函数，其他函数也是如此，所以，为了让我们写的驱动能够正常的被应用程序操作，首先要做的就是实现相应的方法，然后再创建相应的设备文件。
    在打开Binder设备之后，进程还会通过mmap进行内存映射。mmap的作用有如下两个：
- 申请一块内存空间，用来接收Binder通信过程中的数据
- 对这块内存进行地址映射，以便将来访问
```

### 1.3 IPC机制了解一下

```
- Socket(套接字) ： 主要用于不通机器或跨网络的通信，传输效率低
- Signal(信号) ： 适用于进程中断控制，比如非法内存访问，杀死某个进程等
- Pipe(管道) ： 在创建时分配一个page大小的内存，缓存区大小比较有限
- Message Queue ： 信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信
- Semaphore(信号量) : 常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段
- Shared Memory(共享内存) : 无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；
....等等
```

### 1.4 Binder与C/S体系结构体会一下

```
- 用户端(Client) : 是C/S体系结构中使用Server端提供的Service的一方
- 服务端(Server) : 是C/S体系结构中为Client端提供Service的一方
- 服务代理(Proxy): 位于Client端, 提供访问服务的接口。主要作用是屏蔽用户端和Server端通讯的细节, 如对请求数据的序列化和对响应数据的反序列化、通信协议的处理等。
- 服务(Service): 运行在Server端，提供具体的功能处理Client端的请求。
- 服务存根(Stub): 位于Server端, 屏蔽了Proxy和Service端通信的细节，对Client端Proxy请求数据的反序列化和对Server端响应数据的序列化、通信协议的封装和处理、匹配Client端调用Service的具体方法，可以看作是Service的代理
- 通信协议：Client端和Server端可以运行于不同的进程中，甚至可以在不同的主机中，因此需要提供远程通信功能。在Android中，主要使用Binder作为Client端与Server端通信的协议。
```

### 1.5 ServiceManager

![image_1cbjv1brnoa21sc21coacpb1rtrm.png-187.2kB][C/S和ServiceManager]

```
    在Android的C/S体系结构中增加了一个额外的组件ServiceManager, 提供了Service注册和Service检索功能。Service在启动过程中将自身信息注册到ServiceManager中,因此ServiceManager中维护了一个Service信息的列表。当Client要使用服务时，只需向ServiceManager提供所需Service的名字便可获取Service信息。ServiceManager是由init启动的进程，本身也是一个Server。
    ServiceManager是在init.rc中配置的Daemon System Service, 由boot Action 启动。ServiceManager优先于其他服务启动，在其启动后， 便可以对外提供服务注册、服务检索的功能。除此之外，它还维护了一个Binder通讯的上下文管理者(context manager)。
     ServiceManger是在系统启动阶段由init启动的service,对应可执行程序名为/system/bin/servicemanager。其程序入口为service_manager.c。
```

```
service servicemanager /system/bin/servicemanager
    class core 		# 类型为core，将由boot Action启动
    user system 	# 属于system用户
    group system	# 属于system组
    critical		# critical服务, 异常退出后盖服务需要重启
    # servicemanager 重启会导致以下服务重启
    onrestart restart healthd 	
    onrestart restart zygote
    onrestart restart media
    onrestart restart surfaceflinger
    onrestart restart drm
```

- service_manager.c

```ruby
/**
 * 1. 初始化Binder通信环境，打开Binder设备并映射共享内存
 * 2. 将自身注册为上下文管理者
 * 3. 进入无限循环等待接收并处理IPC通信请求
 **/
int main(int argc, char **argv)
{
    struct binder_state *bs;
    void *svcmgr = BINDER_SERVICE_MANAGER;
    // 打开Binder设备, 映射共享内存用于接收IPC通信数据, 申请的内存为128k
    bs = binder_open(128*1024);
    // 将service_manager注册为context manager
    if (binder_become_context_manager(bs)) {
        return -1;
    }
    svcmgr_handle = svcmgr;
    // 进入无限循环等待接受IPC通信数据
    binder_loop(bs, svcmgr_handler);
    return 0;
}
```

### 1.6 Binder的初始化

ServiceManager调用binder_open函数初始化Binder通信环境

- binder.c

```ruby
struct binder_state *binder_open(unsigned mapsize)
{
    // 创建binder_state类型结构体 bs，并分配内存
    struct binder_state *bs;
    bs = malloc(sizeof(*bs));
    if (!bs) {
        errno = ENOMEM;
        return 0;
    }
    // 通过open系统调用以读写方式方式打开设备文件
    bs->fd = open("/dev/binder", O_RDWR);
    if (bs->fd < 0) {
        fprintf(stderr,"binder: cannot open device (%s)\n",
                strerror(errno));
        goto fail_open;
    }
    // 通过mmap系统调用将设备文件映射到当前进程的虚拟地址空间
    bs->mapsize = mapsize;
    bs->mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs->fd, 0);
    if (bs->mapped == MAP_FAILED) {
        fprintf(stderr,"binder: cannot map device (%s)\n",
                strerror(errno));
        goto fail_map;
    }

        /* TODO: check version */

    return bs;

fail_map:
    close(bs->fd);
fail_open:
    free(bs);
    return 0;
}

```









[back](./)

------
作者 : [口戛口崩月危.Z][author]

[author]: https://zaze359.github.io
[为什么Android要采用Binder作为IPC机制]:https://www.zhihu.com/question/39440766/answer/89210950
[C/S和ServiceManager]: http://static.zybuluo.com/zaze/hd4k8fd8y0ky6lljv86bwkd9/image_1cbjv1brnoa21sc21coacpb1rtrm.png
[Linux设备驱动之字符设备驱动]: https://blog.csdn.net/andylauren/article/details/51803331
[Linux字符设备驱动框架]: https://www.cnblogs.com/xiaojiang1025/p/6181833.html